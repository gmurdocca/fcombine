/* $OpenBSD: sftp-server.c,v 1.84 2008/06/26 06:10:09 djm Exp $ */
/*
 * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "includes.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
#ifdef HAVE_SYS_STATVFS_H
#include <sys/statvfs.h>
#endif

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "uidswap.h"

#include "sftp.h"
#include "sftp-common.h"

/* helper */
#define get_int64()			buffer_get_int64(&iqueue);
#define get_int()			buffer_get_int(&iqueue);
#define get_string(lenp)		buffer_get_string(&iqueue, lenp);

/* Our verbosity */
LogLevel log_level = SYSLOG_LEVEL_INFO;

/* Our client */
struct passwd *pw = NULL;
char *client_addr = NULL;

/* input and output queue */
Buffer iqueue;
Buffer oqueue;

/* Version of client */
int version;

/* portable attributes, etc. */

typedef struct Stat Stat;

struct Stat {
	char *name;
	char *long_name;
	Attrib attrib;
};

/* Fcombine modifications */

char *vroot;
int jail = 0;

static void
plogit (const char* fmt, ...)
{
	va_list args;
	char *fmt2;

	fmt2 = xmalloc(64 + 1 + 255 + 2 + strlen(fmt) + 1); // username + @ + source_address + ": " + length_of_original_format_string + '\0'
	fmt2 = strcpy(fmt2, pw->pw_name);
	fmt2 = strcat(fmt2, "@");
	fmt2 = strcat(fmt2, client_addr);
	fmt2 = strcat(fmt2, ": ");
	fmt2 = strcat(fmt2, fmt);
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_INFO, fmt2, args);
	va_end(args);
	xfree(fmt2);
}

static char *                                            
vroot_error (char* rpath, char* fmt, ...)
{
  va_list args;

  if(fmt)
  {
    va_start(args, fmt);
    plogit(fmt, args);
    va_end(args);
  }
  rpath[0] = '\0';
  return rpath;
}


/* first_parts and last_part must be buffers of size strlen(path) + 1 */
static void
split_path (char *path, char *first_parts, char *last_part)
{
	char *last_slash;
	/* Get start pointer */
	char *start = path;
	/* Skip past any leading slashes */
	while (start[0] == '/') start++;
	/* Find the last slash, and also handle there not being one */
	if ((last_slash = strrchr(start, '/')) == NULL)
  {
		strcpy(first_parts, "/");
		strcpy(last_part, start);
	}
  else
  {
		/* Copy in everything from the start up to the last slash */
		strncpy(first_parts, start, last_slash - start);
		/* Overwrite that last slash with a null */
		first_parts[(last_slash - start)] = '\0';
		strcpy(last_part, last_slash + 1);
	}
}

static char *
strip_vroot(char *oldpath)
{
    int len_oldpath;
    char *newpath;
	int len_vroot = strlen(vroot);

	if (!jail)
		return oldpath;

    len_oldpath = strlen(oldpath);
    newpath = xmalloc(len_oldpath - len_vroot + 2);
    strcpy(newpath, oldpath+len_vroot);
    if (newpath[0] == '\0') {
        xfree(newpath);
        newpath = xstrdup("/");
    }
    xfree(oldpath);
    return newpath;
}

static char *
apply_vroot(char *oldpath)
{
    int len_oldpath;
    char *slashedpath;
    char *vrootedpath;
	int len_vroot = strlen(vroot);

    len_oldpath = strlen(oldpath);
    slashedpath = xmalloc(len_vroot + len_oldpath + 2);  /* +2 because ... +1 for the \0 terminator, and another +1 for a possible slash that might need to be put in between vroot and oldpath */
    vrootedpath = xmalloc(len_vroot + len_oldpath + 2);
    /* Check if path has preceding '/' - if not, add it */
    if (oldpath[0] != '/') {
        strcpy(slashedpath, "/");
        strcat(slashedpath, oldpath);
    } else {
        strcpy(slashedpath, oldpath);
    }
    /* Now prepend the vroot, store in temppath2 */
    strcpy(vrootedpath, vroot);
    strcat(vrootedpath, slashedpath);
    xfree(oldpath);
    xfree(slashedpath);
    return vrootedpath;
}

/* Return the canonical absolute name of file NAME.  A canonical name
   does not contain any `.', `..' components nor any repeated file name
   separators ('/') or symlinks. The result is malloc'd.
   oldpath must be an xmalloc'd buffer.
   The function returns an xmalloc'd buffer, which must be freed by the caller.
   (The returned buffer may be the same as the buffer that was passed in)
*/
static char *
realpath_vroot_full(char *oldpath)
{
  char *rname, *dest, *extra_buf = NULL; /* The building location. extra_buf may be used to replace oldpath if we need to expand a symlink */
  char *start; /* start and end are pointers into oldpath or extra_buf. They mark the start and end of a path_part */
  char *end;
  char *rname_limit; /* The end of the rname buffer? */
  size_t extra_len = 0; /* ? */
  int num_links = 0;

  if (!jail)
    return oldpath;

  if (oldpath[0] == '\0')
    {
      return vroot_error(oldpath, "realpath_vroot_full received empty string");
    }

  rname = xmalloc (MAXPATHLEN);
  rname_limit = rname + MAXPATHLEN;
  rname[0] = '/';
  dest = rname + 1;

  for (start = end = oldpath; *start; start = end)
  {
    /* Skip sequence of multiple file name separators. start points at the char after any '/' chars */
    while (*start == '/')
      ++start;
    /* Find end of component - ie end will point to the char that is the next '/' or the char that is the '\0' on the end of the string  */
    for (end = start; *end && *end != '/'; ++end)
      ; /* Do nothing */
    if (end - start == 0) /* This can only happen if there was a trailing slash. If so, then we're done, so break out of the for loop */
      break;
    else if (end - start == 1 && start[0] == '.') /* If the path part was 1 char long and the char was a '.', do nothing*/
      ; /* Do nothing */
    else if (end - start == 2 && start[0] == '.' && start[1] == '.') /* If the path part was 2 chars long and those two chars were '..', then back up the previous component in rname */
    {
      /* Back up to previous component, ignore if at root already.  */
      if (dest > rname + 1)
        while ((--dest)[-1] != '/');
    }
    else /* Else, we've found something interesting - either a file, dir or symlink */
    {
      struct stat st;
      if (dest[-1] != '/') 
        *dest++ = '/';

      if (dest + (end - start) >= rname_limit)
      {
        int dest_offset = dest - rname;
        size_t new_size = rname_limit - rname;

        if (end - start + 1 > MAXPATHLEN)
          new_size += end - start + 1;
        else
          new_size += MAXPATHLEN;
        rname = xrealloc (rname, new_size, sizeof(char));
        rname_limit = rname + new_size;
        dest = rname + dest_offset;
      }

      dest = memcpy (dest, start, end - start);
      dest += end - start;
      *dest = '\0';

      /* We need to temporarily apply the vroot to rname so we can stat the latest path part we just tacked on
       * We will create a new buffer called vrooted_rname to do this */
      char* vrooted_rname = xstrdup(rname);
      vrooted_rname = apply_vroot(vrooted_rname);
      debug("REALPATH VROOT: vrooted rpath (after vrooting) is %s", vrooted_rname);

      if (lstat(vrooted_rname, &st) < 0) {
        xfree(vrooted_rname);
        xfree(oldpath);
        return vroot_error(rname, NULL);
      }

      if (S_ISLNK (st.st_mode))
      {
        char *buf;
        size_t n, len;

        if (++num_links > MAXSYMLINKS)
        { 
          xfree(oldpath);
          xfree(vrooted_rname);
          return vroot_error(rname, "Too many symlinks");
        }

        buf = xmalloc(MAXPATHLEN);
        n = readlink(vrooted_rname, buf, MAXPATHLEN - 1);
        xfree(vrooted_rname);

        if (n < 0) {
          xfree(buf);
          xfree(oldpath);
          return vroot_error(rname, "Couldn't read symlink");
        }

        buf[n] = '\0';
        len = strlen (end);

        if (!extra_len)
        {
          extra_len = ((n + len + 1) > MAXPATHLEN) ? (n + len + 1) : MAXPATHLEN;
          extra_buf = xmalloc (extra_len);
          memmove (&extra_buf[n], end, len + 1);
          xfree(oldpath);
        }
        else if ((n + len + 1) > extra_len)
        {
          extra_len = n + len + 1;
          extra_buf = xrealloc (extra_buf, extra_len, sizeof(char));
          memmove(&extra_buf[n], end, len + 1);
        }
        else {
          memmove(&extra_buf[n], end, len + 1);
        }

        oldpath = end = memcpy(extra_buf, buf, n);

        if (buf[0] == '/')
          dest = rname + 1; /* It's an absolute symlink */
        else if (dest > rname + 1) /* Back up to previous component, ignore if at root already: */
          while ((--dest)[-1] != '/');
        xfree (buf);
      } /* End of If we found a symlink */
      else if (!S_ISDIR (st.st_mode) && *end != '\0')
      {
        xfree(oldpath);
        return vroot_error(rname, "Invalid path");
      }
    } /* End of Else we found a symlink, dir or file */
  } /* End of the big for loop that goes through the path parts */
  /* Don't return trailing slash */
  if (dest > rname + 1 && dest[-1] == '/')
    --dest;
  *dest = '\0';
  rname = apply_vroot(rname);
  return rname;
}

static char *
realpath_vroot_partial(char *oldpath, int last_part_must_exist)
{
	char *first_parts, *last_part;
	struct stat st;
	int ret;

	if (!jail)
		return oldpath;

	/* If oldpath is empty string, return empty string */
	if (strlen(oldpath) == 0)
		return oldpath;
	/* If oldpath == '/', return vroot */
	if (strcmp(oldpath, "/") == 0) {
		xfree(oldpath);
		return xstrdup(vroot);
	}
	/* Split oldpath into first_parts and last_part */
	first_parts = xmalloc(strlen(oldpath) + 1);
	last_part = xmalloc(strlen(oldpath) + 1);
	split_path(oldpath, first_parts, last_part);
	xfree(oldpath);
	
	first_parts = realpath_vroot_full(first_parts);
	/* If realpath_vroot_full returned an empty string, then we do the same */
	if (strlen(first_parts) == 0) {
		xfree(last_part);
		return first_parts;
	}
	/* Construct the full path first_parts + / + last_part */
	first_parts = xrealloc(first_parts, strlen(first_parts) + strlen(last_part) + 2, sizeof(char));
	strcat(first_parts, "/");
	strcat(first_parts, last_part);
	xfree(last_part);
	if (last_part_must_exist) {
		/* See if the resulting file exists */
		ret = lstat(first_parts, &st);
		/* If file doesn't exist, return empty string */
		if (ret < 0 ) {
			first_parts[0] = '\0';
			return first_parts;
		}
	}
	/* Otherwise, return the full path */
	return first_parts;
}

static char *
realpath_vroot_link(char *oldpath)
{
	if (!jail)
		return oldpath;
	return realpath_vroot_partial(oldpath, 1);
}

static char *
realpath_vroot_end(char *oldpath)
{

	struct stat st;
	char *link_value, *newpath, *first_parts, *last_part;
	int symlinks = 0;
	int n;

	if (!jail)
		return oldpath;

	oldpath = realpath_vroot_partial(oldpath, 0);
	/* If oldpath exists and is a symlink */
	while (lstat(oldpath, &st) == 0 && S_ISLNK(st.st_mode) && symlinks < MAXSYMLINKS) {
		symlinks++;
		/* Check if max symlinks reached */
		/* Resolve the link */
		link_value = xmalloc(MAXPATHLEN + 1);
		if ((n = readlink(oldpath, link_value, MAXPATHLEN + 1)) < 0) {
			/* If we can't read the link value, return empty string */
			xfree(link_value);
			oldpath[0] = '\0';
			return oldpath;
		}
		link_value[n] = '\0';
		/* If link is absolute */
		if (link_value[0] == '/') {
			newpath = xmalloc(strlen(link_value) + 2);
			strcpy(newpath, link_value);
			/* Add trailing slash if oldpath has a trailing slash */
			if (oldpath[strlen(oldpath) - 1] == '/')
				strcat(newpath, "/");
      		newpath = realpath_vroot_partial(newpath, 0);
		} else { /* link is relative */
			/* Strip the vroot off oldpath */
			oldpath = strip_vroot(oldpath);
			/* oldpath now starts with a /, and has 0 or more chars after that first slash. He may or may not end in a slash */
			/* Split oldpath into his respective parts */
			newpath = xmalloc(strlen(link_value) + strlen(oldpath) + 2);
			first_parts = xmalloc(strlen(oldpath) + 1);
			last_part = xmalloc(strlen(oldpath) + 1);
			split_path(oldpath, first_parts, last_part);
			/* Start building the new path string in newpath */
			strcpy(newpath, first_parts);
			/* first_parts starts with a /, and may have 0 or more chars after it. It does not end in a /. */
			/* If last_part is a "/" */
			if (strcmp(last_part, "/") == 0) { 
				/* then the last bit of first_parts is the symlink and we need to nuke it, */
				newpath[(strrchr(newpath, '/') - newpath) + 1] = '\0';
				strcat(newpath, link_value);
				/* Also, we will need to include a trailing slash in the final thing. */
				strcat(newpath, "/");
 			} else {
				/* last_part is the symlink part and we don't need it */
				strcat(newpath, "/");
				strcat(newpath, link_value);
				/* There will be no trailing slash on the final thing */
			}
			newpath = realpath_vroot_partial(newpath, 0);
			xfree(first_parts);
			xfree(last_part);
		}
		xfree(link_value);
		/* Feed newpath back into this algorithm */
		xfree(oldpath);
		oldpath = newpath;
	} /* end of "oldpath is a symlink" code */
	if (symlinks == MAXSYMLINKS) {
		oldpath[0] = '\0';
	}
	return oldpath;
}

/* End Fcombine modifications */

static int
errno_to_portable(int unixerrno)
{
	int ret = 0;

	switch (unixerrno) {
	case 0:
		ret = SSH2_FX_OK;
		break;
	case ENOENT:
	case ENOTDIR:
	case EBADF:
	case ELOOP:
		ret = SSH2_FX_NO_SUCH_FILE;
		break;
	case EPERM:
	case EACCES:
	case EFAULT:
		ret = SSH2_FX_PERMISSION_DENIED;
		break;
	case ENAMETOOLONG:
	case EINVAL:
		ret = SSH2_FX_BAD_MESSAGE;
		break;
	case ENOSYS:
		ret = SSH2_FX_OP_UNSUPPORTED;
		break;
	default:
		ret = SSH2_FX_FAILURE;
		break;
	}
	return ret;
}

static int
flags_from_portable(int pflags)
{
	int flags = 0;

	if ((pflags & SSH2_FXF_READ) &&
	    (pflags & SSH2_FXF_WRITE)) {
		flags = O_RDWR;
	} else if (pflags & SSH2_FXF_READ) {
		flags = O_RDONLY;
	} else if (pflags & SSH2_FXF_WRITE) {
		flags = O_WRONLY;
	}
	if (pflags & SSH2_FXF_CREAT)
		flags |= O_CREAT;
	if (pflags & SSH2_FXF_TRUNC)
		flags |= O_TRUNC;
	if (pflags & SSH2_FXF_EXCL)
		flags |= O_EXCL;
	return flags;
}

static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

static Attrib *
get_attrib(void)
{
	return decode_attrib(&iqueue);
}

/* handle handles */

typedef struct Handle Handle;
struct Handle {
	int use;
	DIR *dirp;
	int fd;
	char *name;
	u_int64_t bytes_read, bytes_write;
	int next_unused;
};

enum {
	HANDLE_UNUSED,
	HANDLE_DIR,
	HANDLE_FILE
};

Handle *handles = NULL;
u_int num_handles = 0;
int first_unused_handle = -1;

static void handle_unused(int i)
{
	handles[i].use = HANDLE_UNUSED;
	handles[i].next_unused = first_unused_handle;
	first_unused_handle = i;
}

static int
handle_new(int use, const char *name, int fd, DIR *dirp)
{
	int i;

	if (first_unused_handle == -1) {
		if (num_handles + 1 <= num_handles)
			return -1;
		num_handles++;
		handles = xrealloc(handles, num_handles, sizeof(Handle));
		handle_unused(num_handles - 1);
	}

	i = first_unused_handle;
	first_unused_handle = handles[i].next_unused;

	handles[i].use = use;
	handles[i].dirp = dirp;
	handles[i].fd = fd;
	handles[i].name = xstrdup(name);
	handles[i].bytes_read = handles[i].bytes_write = 0;

	return i;
}

static int
handle_is_ok(int i, int type)
{
	return i >= 0 && (u_int)i < num_handles && handles[i].use == type;
}

static int
handle_to_string(int handle, char **stringp, int *hlenp)
{
	if (stringp == NULL || hlenp == NULL)
		return -1;
	*stringp = xmalloc(sizeof(int32_t));
	put_u32(*stringp, handle);
	*hlenp = sizeof(int32_t);
	return 0;
}

static int
handle_from_string(const char *handle, u_int hlen)
{
	int val;

	if (hlen != sizeof(int32_t))
		return -1;
	val = get_u32(handle);
	if (handle_is_ok(val, HANDLE_FILE) ||
	    handle_is_ok(val, HANDLE_DIR))
		return val;
	return -1;
}

static char *
handle_to_name(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR)||
	    handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].name;
	return NULL;
}

static DIR *
handle_to_dir(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR))
		return handles[handle].dirp;
	return NULL;
}

static int
handle_to_fd(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].fd;
	return -1;
}

static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

static int
handle_close(int handle)
{
	int ret = -1;

	if (handle_is_ok(handle, HANDLE_FILE)) {
		ret = close(handles[handle].fd);
		xfree(handles[handle].name);
		handle_unused(handle);
	} else if (handle_is_ok(handle, HANDLE_DIR)) {
		ret = closedir(handles[handle].dirp);
		xfree(handles[handle].name);
		handle_unused(handle);
	} else {
		errno = ENOENT;
	}
	return ret;
}

static void
handle_log_close(int handle, char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		plogit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    (unsigned long long)handle_bytes_read(handle),
		    (unsigned long long)handle_bytes_write(handle));
	} else {
		plogit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < num_handles; i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

static int
get_handle(void)
{
	char *handle;
	int val = -1;
	u_int hlen;

	handle = get_string(&hlen);
	if (hlen < 256)
		val = handle_from_string(handle, hlen);
	xfree(handle);
	return val;
}

/* send replies */

static void
send_msg(Buffer *m)
{
	int mlen = buffer_len(m);

	buffer_put_int(&oqueue, mlen);
	buffer_append(&oqueue, buffer_ptr(m), mlen);
	buffer_consume(m, mlen);
}

static const char *
status_to_message(u_int32_t status)
{
	const char *status_messages[] = {
		"Success",			/* SSH_FX_OK */
		"End of file",			/* SSH_FX_EOF */
		"No such file",			/* SSH_FX_NO_SUCH_FILE */
		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
		"Failure",			/* SSH_FX_FAILURE */
		"Bad message",			/* SSH_FX_BAD_MESSAGE */
		"No connection",		/* SSH_FX_NO_CONNECTION */
		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
		"Unknown error"			/* Others */
	};
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
}

static void
send_status(u_int32_t id, u_int32_t status)
{
	Buffer msg;

	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		plogit("sent status %s", status_to_message(status));
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_STATUS);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, status);
	if (version >= 3) {
		buffer_put_cstring(&msg, status_to_message(status));
		buffer_put_cstring(&msg, "");
	}
	send_msg(&msg);
	buffer_free(&msg);
}
static void
send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
{
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, type);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, data, dlen);
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_data(u_int32_t id, const char *data, int dlen)
{
	debug("request %u: sent data len %d", id, dlen);
	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
}

static void
send_handle(u_int32_t id, int handle)
{
	char *string;
	int hlen;

	handle_to_string(handle, &string, &hlen);
	debug("request %u: sent handle handle %d", id, handle);
	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
	xfree(string);
}

static void
send_names(u_int32_t id, int count, const Stat *stats)
{
	Buffer msg;
	int i;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_NAME);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, count);
	debug("request %u: sent names count %d", id, count);
	for (i = 0; i < count; i++) {
		buffer_put_cstring(&msg, stats[i].name);
		buffer_put_cstring(&msg, stats[i].long_name);
		encode_attrib(&msg, &stats[i].attrib);
	}
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_attrib(u_int32_t id, const Attrib *a)
{
	Buffer msg;

	debug("request %u: sent attrib have 0x%x", id, a->flags);
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_ATTRS);
	buffer_put_int(&msg, id);
	encode_attrib(&msg, a);
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_statvfs(u_int32_t id, struct statvfs *st)
{
	Buffer msg;
	u_int64_t flag;

	flag = (st->f_flag & ST_RDONLY) ? SSH2_FXE_STATVFS_ST_RDONLY : 0;
	flag |= (st->f_flag & ST_NOSUID) ? SSH2_FXE_STATVFS_ST_NOSUID : 0;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED_REPLY);
	buffer_put_int(&msg, id);
	buffer_put_int64(&msg, st->f_bsize);
	buffer_put_int64(&msg, st->f_frsize);
	buffer_put_int64(&msg, st->f_blocks);
	buffer_put_int64(&msg, st->f_bfree);
	buffer_put_int64(&msg, st->f_bavail);
	buffer_put_int64(&msg, st->f_files);
	buffer_put_int64(&msg, st->f_ffree);
	buffer_put_int64(&msg, st->f_favail);
	buffer_put_int64(&msg, FSID_TO_ULONG(st->f_fsid));
	buffer_put_int64(&msg, flag);
	buffer_put_int64(&msg, st->f_namemax);
	send_msg(&msg);
	buffer_free(&msg);
}

/* parse incoming */

/* Receives client version, sends server version and supported extension commands */
static void
process_init(void)
{
	Buffer msg;

	version = get_int();
	verbose("received client version %d", version);
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_VERSION);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
	/* POSIX rename extension */
	buffer_put_cstring(&msg, "posix-rename@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
	/* statvfs extension */
	buffer_put_cstring(&msg, "statvfs@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	/* fstatvfs extension */
	buffer_put_cstring(&msg, "fstatvfs@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	send_msg(&msg);
	buffer_free(&msg);
}

/* Open or create a file ...
 * int      id = message_id
 * string   name = file_name
 * int      pflags = READ | WRITE | APPEND | CREATE | TRUNCATE | EXCL(NO OVERWRITE)
 * ATTRS    attrs = file attributes
 *
 * Sends to client ...
 * int      handle = file handle, or status = an error status
 * */
static void
process_open(void)
{
	u_int32_t id, pflags;
	Attrib *a;
	char *name;
	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	name = realpath_vroot_end(name); /* vroot_realpath_end - we don't care if the last bit doesn't exist */
	pflags = get_int();		/* portable flags */
	debug3("request %u: open flags %d", id, pflags);
	a = get_attrib();
	flags = flags_from_portable(pflags);
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
	plogit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
	fd = open(name, flags, mode);
	if (fd < 0) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_FILE, name, fd, NULL);
		if (handle < 0) {
			close(fd);
		} else {
			send_handle(id, handle);
			status = SSH2_FX_OK;
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(name);
}

/* Takes in an int as the previously opened file handle, returns a status int */
static void
process_close(void)
{
	u_int32_t id;
	int handle, ret, status = SSH2_FX_FAILURE;

	id = get_int();
	handle = get_handle();
	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
	ret = handle_close(handle);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
}

/* Takes in an int as the previously opened file handle, returns data or a status int */
static void
process_read(void)
{
	char buf[64*1024];
	u_int32_t id, len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
	u_int64_t off;

	id = get_int();
	handle = get_handle();
	off = get_int64();
	len = get_int();

	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	if (len > sizeof buf) {
		len = sizeof buf;
		debug2("read change len %d", len);
	}
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		if (lseek(fd, off, SEEK_SET) < 0) {
			error("process_read: seek failed");
			status = errno_to_portable(errno);
		} else {
			ret = read(fd, buf, len);
			if (ret < 0) {
				status = errno_to_portable(errno);
			} else if (ret == 0) {
				status = SSH2_FX_EOF;
			} else {
				send_data(id, buf, ret);
				status = SSH2_FX_OK;
				handle_update_read(handle, ret);
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

/* Takes in an int as the previously opened file handle, a bunch of data and returns a status int */
static void
process_write(void)
{
	u_int32_t id;
	u_int64_t off;
	u_int len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
	char *data;

	id = get_int();
	handle = get_handle();
	off = get_int64();
	data = get_string(&len);

	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		if (lseek(fd, off, SEEK_SET) < 0) {
			status = errno_to_portable(errno);
			error("process_write: seek failed");
		} else {
/* XXX ATOMICIO ? */
			ret = write(fd, data, len);
			if (ret < 0) {
				error("process_write: write failed");
				status = errno_to_portable(errno);
			} else if ((size_t)ret == len) {
				status = SSH2_FX_OK;
				handle_update_write(handle, ret);
			} else {
				debug2("nothing at all written");
			}
		}
	}
	send_status(id, status);
	xfree(data);
}

/* stat does not include a filename */
static void
process_do_stat(int do_lstat)
{
	Attrib a;
	struct stat st;
	u_int32_t id;
	char *name;
	int ret, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	if (do_lstat) {
		name = realpath_vroot_link(name); /* If stat, then do realpath_vroot_full. But if lstat, do realpath_vroot_link */
	} else {
		name = realpath_vroot_full(name);
	}
	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
	ret = do_lstat ? lstat(name, &st) : stat(name, &st);
	if (ret < 0) {
		status = errno_to_portable(errno);
	} else {
		stat_to_attrib(&st, &a);
		send_attrib(id, &a);
		status = SSH2_FX_OK;
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(name);
}

static void
process_stat(void)
{
	process_do_stat(0);
}

static void
process_lstat(void)
{
	process_do_stat(1);
}

/* Only operates on a previously opened file */
static void
process_fstat(void)
{
	Attrib a;
	struct stat st;
	u_int32_t id;
	int fd, ret, handle, status = SSH2_FX_FAILURE;

	id = get_int();
	handle = get_handle();
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		ret = fstat(fd, &st);
		if (ret < 0) {
			status = errno_to_portable(errno);
		} else {
			stat_to_attrib(&st, &a);
			send_attrib(id, &a);
			status = SSH2_FX_OK;
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

static struct timeval *
attrib_to_tv(const Attrib *a)
{
	static struct timeval tv[2];

	tv[0].tv_sec = a->atime;
	tv[0].tv_usec = 0;
	tv[1].tv_sec = a->mtime;
	tv[1].tv_usec = 0;
	return tv;
}

/* Takes in a name (need to intercept this), and returns a status (no need to intercept) */
static void
process_setstat(void)
{
	Attrib *a;
	u_int32_t id;
	char *name;
	int status = SSH2_FX_OK, ret;

	id = get_int();
	name = get_string(NULL);
	name = realpath_vroot_full(name); /* Bog standard realpath_vroot_full. Although what if we want to setstat on a symlink? XXX Maybe for V2 */
	a = get_attrib();
	debug("request %u: setstat name \"%s\"", id, name);
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		plogit("set \"%s\" size %llu",
		    name, (unsigned long long)a->size);
		ret = truncate(name, a->size);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		plogit("set \"%s\" mode %04o", name, a->perm);
		ret = chmod(name, a->perm & 07777);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
		char buf[64];
		time_t t = a->mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		plogit("set \"%s\" modtime %s", name, buf);
		ret = utimes(name, attrib_to_tv(a)); /* XXX How does utimes handle a file that is too long, or doesn't exist? */
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
		plogit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a->uid, (u_long)a->gid);
		ret = chown(name, a->uid, a->gid);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	send_status(id, status);
	xfree(name);
}

/* Takes in a filehandle int, and returns a status (no need to intercept) */
static void
process_fsetstat(void)
{
	Attrib *a;
	u_int32_t id;
	int handle, fd, ret;
	int status = SSH2_FX_OK;

	id = get_int();
	handle = get_handle();
	a = get_attrib();
	debug("request %u: fsetstat handle %d", id, handle);
	fd = handle_to_fd(handle);
	if (fd < 0) {
		status = SSH2_FX_FAILURE;
	} else {
		char *name = handle_to_name(handle);

		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
			plogit("set \"%s\" size %llu",
			    name, (unsigned long long)a->size);
			ret = ftruncate(fd, a->size);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
			plogit("set \"%s\" mode %04o", name, a->perm);
#ifdef HAVE_FCHMOD
			ret = fchmod(fd, a->perm & 07777);
#else
			ret = chmod(name, a->perm & 07777);
#endif
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
			char buf[64];
			time_t t = a->mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			plogit("set \"%s\" modtime %s", name, buf);
#ifdef HAVE_FUTIMES
			ret = futimes(fd, attrib_to_tv(a));
#else
			ret = utimes(name, attrib_to_tv(a));
#endif
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
			plogit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a->uid, (u_long)a->gid);
#ifdef HAVE_FCHOWN
			ret = fchown(fd, a->uid, a->gid);
#else
			ret = chown(name, a->uid, a->gid);
#endif
			if (ret == -1)
				status = errno_to_portable(errno);
		}
	}
	send_status(id, status);
}

/* Takes in a path string (need to intercept), returns a handle or a status (both ints, no need to intercept) */
static void
process_opendir(void)
{
	DIR *dirp = NULL;
	char *path;
	int handle, status = SSH2_FX_FAILURE;
	u_int32_t id;

	id = get_int();
	path = get_string(NULL);
	path = realpath_vroot_full(path); /* realpath_vroot_full */
	debug3("request %u: opendir", id);
	plogit("opendir \"%s\"", path);
	dirp = opendir(path);
	if (dirp == NULL) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_DIR, path, 0, dirp);
		if (handle < 0) {
			closedir(dirp);
		} else {
			send_handle(id, handle);
			status = SSH2_FX_OK;
		}

	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(path);
}

static void
process_readdir(void)
{
	DIR *dirp;
	struct dirent *dp;
	char *path;
	int handle;
	u_int32_t id;

	id = get_int();
	handle = get_handle();
	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
	dirp = handle_to_dir(handle);
	path = handle_to_name(handle); /* We DON'T need to intercept, because it would already be done when the DIR was opened */
	if (dirp == NULL || path == NULL) {
		send_status(id, SSH2_FX_FAILURE);
	} else {
		struct stat st;
		char pathname[MAXPATHLEN];
		Stat *stats;
		int nstats = 10, count = 0, i;

		stats = xcalloc(nstats, sizeof(Stat));
		while ((dp = readdir(dirp)) != NULL) {
			if (count >= nstats) {
				nstats *= 2;
				stats = xrealloc(stats, nstats, sizeof(Stat));
			}
/* XXX OVERFLOW ? */
			snprintf(pathname, sizeof pathname, "%s%s%s", path,
			    strcmp(path, "/") ? "/" : "", dp->d_name); /* We DON'T need to intercept this and strip the vroot from "path", because the "path" is just used to identify the file for the following lstat */
			if (lstat(pathname, &st) < 0)
				continue;
			stat_to_attrib(&st, &(stats[count].attrib));
			stats[count].name = xstrdup(dp->d_name);
			stats[count].long_name = ls_file(dp->d_name, &st, 0); /* What does ls_file do? It just expands out a bunch of info about the file and puts it in one big string. It does NOT include the full path to the file */
			count++;
			/* send up to 100 entries in one message */
			/* XXX check packet size instead */
			if (count == 100)
				break;
		}
		if (count > 0) {
			send_names(id, count, stats);
			for (i = 0; i < count; i++) {
				xfree(stats[i].name);
				xfree(stats[i].long_name);
			}
		} else {
			send_status(id, SSH2_FX_EOF);
		}
		xfree(stats);
	}
}

static void
process_remove(void)
{
	char *name;
	u_int32_t id;
	int status = SSH2_FX_FAILURE;
	int ret;

	id = get_int();
	name = get_string(NULL);
	name = realpath_vroot_link(name); /* realpath_vroot_link */
	debug3("request %u: remove", id);
	plogit("remove name \"%s\"", name);
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_mkdir(void)
{
	Attrib *a;
	u_int32_t id;
	char *name;
	int ret, mode, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	name = realpath_vroot_end(name); /* realpath_vroot_end - we don't care if the last bit doesn't exist */
	a = get_attrib();
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a->perm & 07777 : 0777;
	debug3("request %u: mkdir", id);
	plogit("mkdir name \"%s\" mode 0%o", name, mode);
	ret = mkdir(name, mode);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_rmdir(void)
{
	u_int32_t id;
	char *name;
	int ret, status;

	id = get_int();
	name = get_string(NULL);
	name = realpath_vroot_link(name); /* realpath_vroot_link - we don't want to allow a directory to be deleted by rmdir'ing a symlink that points to it, as per OpenSSH's sftp-server behaviour */
	debug3("request %u: rmdir", id);
	plogit("rmdir name \"%s\"", name);
	ret = rmdir(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_realpath(void)
{
	char *resolvedname;
	u_int32_t id;
	char *path;

	resolvedname = xmalloc(MAXPATHLEN);
	id = get_int();
	path = get_string(NULL);
	if (path[0] == '\0') {
		xfree(path);
		path = xstrdup(".");
	}
	path = realpath_vroot_full(path); /* realpath_vroot_full */
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
	if (realpath(path, resolvedname) == NULL) {
		send_status(id, errno_to_portable(errno));
	} else {
		Stat s;
		attrib_clear(&s.attrib);
		resolvedname = strip_vroot(resolvedname); /* strip_vroot on resolvedname */
		s.name = s.long_name = resolvedname;
		send_names(id, 1, &s);
	}
	xfree(resolvedname);
	xfree(path);
}

static void
process_rename(void)
{
	u_int32_t id;
	char *oldpath, *newpath;
	int status;
	struct stat sb;

	id = get_int();
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	oldpath = realpath_vroot_link(oldpath); /* realpath_vroot_link */
	newpath = realpath_vroot_end(newpath); /* realpath_vroot_end */
	debug3("request %u: rename", id);
	plogit("rename old \"%s\" new \"%s\"", oldpath, newpath);
	status = SSH2_FX_FAILURE;
	if (lstat(oldpath, &sb) == -1)
		status = errno_to_portable(errno);
	else if (S_ISREG(sb.st_mode)) {
		/* Race-free rename of regular files */
		if (link(oldpath, newpath) == -1) {
			if (errno == EOPNOTSUPP
#ifdef EXDEV
			    || errno == EXDEV
#endif
#ifdef LINK_OPNOTSUPP_ERRNO
			    || errno == LINK_OPNOTSUPP_ERRNO
#endif
			    ) {
				struct stat st;

				/*
				 * fs doesn't support links, so fall back to
				 * stat+rename.  This is racy.
				 */
				if (stat(newpath, &st) == -1) {
					if (rename(oldpath, newpath) == -1)
						status =
						    errno_to_portable(errno);
					else
						status = SSH2_FX_OK;
				}
			} else {
				status = errno_to_portable(errno);
			}
		} else if (unlink(oldpath) == -1) {
			status = errno_to_portable(errno);
			/* clean spare link */
			unlink(newpath);
		} else
			status = SSH2_FX_OK;
	} else if (stat(newpath, &sb) == -1) {
		if (rename(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else
			status = SSH2_FX_OK;
	}
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_readlink(void)
{
	u_int32_t id;
	int len;
	char *buf;
	char *path;

	buf = xmalloc(MAXPATHLEN);
	id = get_int();
	path = get_string(NULL);
	path = realpath_vroot_link(path); /* realpath_vroot_link */
	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
		send_status(id, errno_to_portable(errno));
	else {
		Stat s;

		buf[len] = '\0';
		buf = strip_vroot(buf);
		attrib_clear(&s.attrib);
		s.name = s.long_name = buf;
		send_names(id, 1, &s);
	}
	xfree(buf);
	xfree(path);
}

static void
process_symlink(void)
{
	u_int32_t id;
	char *oldpath, *newpath;
	int ret, status;

	id = get_int();
	oldpath = get_string(NULL); /* Don't do anything to this guy */
	newpath = get_string(NULL);
	newpath = realpath_vroot_end(newpath); /* realpath_vroot_end - we don't care if the bit at the end doesn't exist */
	debug3("request %u: symlink", id);
	plogit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
	/* this will fail if 'newpath' exists */
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_extended_posix_rename(u_int32_t id)
{
	char *oldpath, *newpath;

	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	oldpath = realpath_vroot_link(oldpath); /* realpath_vroot_link */
	newpath = realpath_vroot_end(newpath); /* realpath_vroot_end */
	debug3("request %u: posix-rename", id);
	plogit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
	if (rename(oldpath, newpath) == -1)
		send_status(id, errno_to_portable(errno));
	else
		send_status(id, SSH2_FX_OK);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_extended_statvfs(u_int32_t id)
{
	char *path;
	struct statvfs st;

	path = get_string(NULL);
	path = realpath_vroot_full(path); /* realpath_vroot_full */
	debug3("request %u: statfs", id);
	plogit("statfs \"%s\"", path);

	if (statvfs(path, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
        xfree(path);
}

/* Uses a handle, not a name, so no Fcombine intercept required */
static void
process_extended_fstatvfs(u_int32_t id)
{
	int handle, fd;
	struct statvfs st;

	handle = get_handle();
	debug("request %u: fstatvfs \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	if ((fd = handle_to_fd(handle)) < 0) {
		send_status(id, SSH2_FX_FAILURE);
		return;
	}
	if (fstatvfs(fd, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
}

static void
process_extended(void)
{
	u_int32_t id;
	char *request;

	id = get_int();
	request = get_string(NULL);
	if (strcmp(request, "posix-rename@openssh.com") == 0)
		process_extended_posix_rename(id);
	else if (strcmp(request, "statvfs@openssh.com") == 0)
		process_extended_statvfs(id);
	else if (strcmp(request, "fstatvfs@openssh.com") == 0)
		process_extended_fstatvfs(id);
	else
		send_status(id, SSH2_FX_OP_UNSUPPORTED);	/* MUST */
	xfree(request);
}

/* stolen from ssh-agent */

static void
process(void)
{
	u_int msg_len;
	u_int buf_len;
	u_int consumed;
	u_int type;
	u_char *cp;

	buf_len = buffer_len(&iqueue);
	if (buf_len < 5)
		return;		/* Incomplete message. */
	cp = buffer_ptr(&iqueue);
	msg_len = get_u32(cp);
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		sftp_server_cleanup_exit(11);
	}
	if (buf_len < msg_len + 4)
		return;
	buffer_consume(&iqueue, 4);
	buf_len -= 4;
	type = buffer_get_char(&iqueue);
	switch (type) {
	case SSH2_FXP_INIT:
		process_init();
		break;
	case SSH2_FXP_OPEN:
		process_open();
		break;
	case SSH2_FXP_CLOSE:
		process_close();
		break;
	case SSH2_FXP_READ:
		process_read();
		break;
	case SSH2_FXP_WRITE:
		process_write();
		break;
	case SSH2_FXP_LSTAT:
		process_lstat();
		break;
	case SSH2_FXP_FSTAT:
		process_fstat();
		break;
	case SSH2_FXP_SETSTAT:
		process_setstat();
		break;
	case SSH2_FXP_FSETSTAT:
		process_fsetstat();
		break;
	case SSH2_FXP_OPENDIR:
		process_opendir();
		break;
	case SSH2_FXP_READDIR:
		process_readdir();
		break;
	case SSH2_FXP_REMOVE:
		process_remove();
		break;
	case SSH2_FXP_MKDIR:
		process_mkdir();
		break;
	case SSH2_FXP_RMDIR:
		process_rmdir();
		break;
	case SSH2_FXP_REALPATH:
		process_realpath();
		break;
	case SSH2_FXP_STAT:
		process_stat();
		break;
	case SSH2_FXP_RENAME:
		process_rename();
		break;
	case SSH2_FXP_READLINK:
		process_readlink();
		break;
	case SSH2_FXP_SYMLINK:
		process_symlink();
		break;
	case SSH2_FXP_EXTENDED:
		process_extended();
		break;
	default:
		error("Unknown message %d", type);
		break;
	}
	/* discard the remaining bytes from the current packet */
	if (buf_len < buffer_len(&iqueue)) {
		error("iqueue grew unexpectedly");
		sftp_server_cleanup_exit(255);
	}
	consumed = buf_len - buffer_len(&iqueue);
	if (msg_len < consumed) {
		error("msg_len %d < consumed %d", msg_len, consumed);
		sftp_server_cleanup_exit(255);
	}
	if (msg_len > consumed)
		buffer_consume(&iqueue, msg_len - consumed);
}

/* Cleanup handler that logs active handles upon normal exit */
void
sftp_server_cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		plogit("session closed");
	}
	_exit(i);
}

static void
sftp_server_usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-hej] [-l log_level] [-f log_facility]\n", __progname);
	exit(1);
}

int
sftp_server_main(int argc, char **argv, struct passwd *user_pw)
{
	fd_set *rset, *wset;
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
	ssize_t len, olen, set_size;
	SyslogFacility log_facility = SYSLOG_FACILITY_LOCAL1;
	char *cp, buf[4*4096];
	char cwd[MAXPATHLEN + 1];   /* +1 for the \0 terminator */

	extern char *optarg;
	extern char *__progname;

	__progname = ssh_get_progname(argv[0]);
	log_init(__progname, log_level, log_facility, log_stderr);

	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:chej")) != -1) {
		switch (ch) {
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_facility == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'j':
			jail = 1;
			break;
		case 'h':
		default:
			sftp_server_usage();
		}
	}

	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL) {
			error("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
			sftp_server_cleanup_exit(255);
		}
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	pw = pwcopy(user_pw);

	plogit("session opened");

	in = dup(STDIN_FILENO);
	out = dup(STDOUT_FILENO);

#ifdef HAVE_CYGWIN
	setmode(in, O_BINARY);
	setmode(out, O_BINARY);
#endif

    /* Fcombine mod */ 
    vroot = xmalloc(MAXPATHLEN + 1); /* +1 to accomodate \0 terminator*/
    getcwd(cwd, (MAXPATHLEN + 1));
    strcpy(vroot, cwd);
    debug("vroot is %s", vroot);
    /* End Fcombine mod */

	max = 0;
	if (in > max)
		max = in;
	if (out > max)
		max = out;

	buffer_init(&iqueue);
	buffer_init(&oqueue);

	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	rset = (fd_set *)xmalloc(set_size);
	wset = (fd_set *)xmalloc(set_size);

	for (;;) {
		memset(rset, 0, set_size);
		memset(wset, 0, set_size);

		/*
		 * Ensure that we can read a full buffer and handle
		 * the worst-case length packet it can generate,
		 * otherwise apply backpressure by stopping reads.
		 */
		if (buffer_check_alloc(&iqueue, sizeof(buf)) &&
		    buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			FD_SET(in, rset);

		olen = buffer_len(&oqueue);
		if (olen > 0)
			FD_SET(out, wset);

		if (select(max+1, rset, wset, NULL, NULL) < 0) {
			if (errno == EINTR)
				continue;
			error("select: %s", strerror(errno));
			sftp_server_cleanup_exit(2);
		}

		/* copy stdin to iqueue */
		if (FD_ISSET(in, rset)) {
			len = read(in, buf, sizeof buf);
			if (len == 0) {
				debug("read eof");
				sftp_server_cleanup_exit(0);
			} else if (len < 0) {
				error("read: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else {
				buffer_append(&iqueue, buf, len);
			}
		}
		/* send oqueue to stdout */
		if (FD_ISSET(out, wset)) {
			len = write(out, buffer_ptr(&oqueue), olen);
			if (len < 0) {
				error("write: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else {
				buffer_consume(&oqueue, len);
			}
		}

		/*
		 * Process requests from client if we can fit the results
		 * into the output buffer, otherwise stop processing input
		 * and let the output queue drain.
		 */
		if (buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			process();
	}
}
